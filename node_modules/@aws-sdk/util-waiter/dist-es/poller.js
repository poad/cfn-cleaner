import { __awaiter, __generator } from "tslib";
import { sleep } from "./utils/sleep";
import { WaiterState } from "./waiter";
var exponentialBackoffWithJitter = function (minDelay, maxDelay, attemptCeiling, attempt) {
    if (attempt > attemptCeiling)
        return maxDelay;
    var delay = minDelay * Math.pow(2, (attempt - 1));
    return randomInRange(minDelay, delay);
};
var randomInRange = function (min, max) { return min + Math.random() * (max - min); };
export var runPolling = function (_a, input, acceptorChecks) {
    var minDelay = _a.minDelay, maxDelay = _a.maxDelay, maxWaitTime = _a.maxWaitTime, abortController = _a.abortController, client = _a.client, abortSignal = _a.abortSignal;
    return __awaiter(void 0, void 0, void 0, function () {
        var _b, state, reason, currentAttempt, waitUntil, attemptCeiling, delay, _c, state_1, reason_1;
        var _d;
        return __generator(this, function (_e) {
            switch (_e.label) {
                case 0: return [4, acceptorChecks(client, input)];
                case 1:
                    _b = _e.sent(), state = _b.state, reason = _b.reason;
                    if (state !== WaiterState.RETRY) {
                        return [2, { state: state, reason: reason }];
                    }
                    currentAttempt = 1;
                    waitUntil = Date.now() + maxWaitTime * 1000;
                    attemptCeiling = Math.log(maxDelay / minDelay) / Math.log(2) + 1;
                    _e.label = 2;
                case 2:
                    if (!true) return [3, 5];
                    if (((_d = abortController === null || abortController === void 0 ? void 0 : abortController.signal) === null || _d === void 0 ? void 0 : _d.aborted) || (abortSignal === null || abortSignal === void 0 ? void 0 : abortSignal.aborted)) {
                        return [2, { state: WaiterState.ABORTED }];
                    }
                    delay = exponentialBackoffWithJitter(minDelay, maxDelay, attemptCeiling, currentAttempt);
                    if (Date.now() + delay * 1000 > waitUntil) {
                        return [2, { state: WaiterState.TIMEOUT }];
                    }
                    return [4, sleep(delay)];
                case 3:
                    _e.sent();
                    return [4, acceptorChecks(client, input)];
                case 4:
                    _c = _e.sent(), state_1 = _c.state, reason_1 = _c.reason;
                    if (state_1 !== WaiterState.RETRY) {
                        return [2, { state: state_1, reason: reason_1 }];
                    }
                    currentAttempt += 1;
                    return [3, 2];
                case 5: return [2];
            }
        });
    });
};
